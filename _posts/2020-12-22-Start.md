---
layout:     post   				    # 使用的布局（不需要改）
title:      My First Post 				# 标题 
subtitle:   I will start my bolg now! #副标题
date:       2020-12-22 				# 时间
author:     Lin_Xuan 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 复习
---

*大晚上的，真的难顶*
## 在搭建博客过程中的测试
**随便放点什么**

# 计组期末复习

目前未知的六次作业，前四次是数据的存储(整数1，2、浮点数3，4)，第五次是汇编指令与C编码的关系与转换、第六次是内存大小的计算方法(机械硬盘和DRAM内存)

### 复习重点：

- 小题占20分、涉及PPT的所有细节

- Two different kinds of CU
- IO module和外设
- IO Technology ：三种不同方式的具体细节，重点关注**中断** 
- 浮点数：可以无缝衔接的原因、进制转换
- Memery Expansion：位扩展、子扩展、同时扩展
- BUs architecture：不同速度的设备使用怎样的架构
- Instruction addressing mode：不同寻址方式及其优缺点、在那种情况来使用
- Memory Capacity：SDRAM容量计算(数据总线、地址总线-复用、片选总线)



## Chapter 1: 简介

#### 大小端问题

小端按内存增大的方式储存，即**低位在前、高位在后**。大端则是相反的**高位在前、低位在后**。但是具体在物理内存上的位置的未知的。上述的内存增大是指储存这个数据的内存。如0xabcd，0xab一字节，0xcd一字节。在小段中，计算机把0xcd存在低地址、0xab存在高地址。而大端则是那0xab存在低地址，二八0xcd存到高地址中。(*我们平时的阅读顺序时大端顺序，即从左往右*)

## Chapter 2: 信息的表示和计算

使用补码进行保存和计算的原因是因为补码可以保证运算正确却是一个Abel群。

无符号/有符号整型之间的转换规则是二进制形式保持不变

### IEEE 754标准

**浮点数的表示**：$(-1)^s\times M*\times2^E$ 

但是，计算机在储存时不仅仅保存s，significant位M和exponent(阶码)E，而是做了一些调整。

| S(1/1)          | Exp(8/11)                     | Frac(23/52)                 |
| --------------- | ----------------------------- | --------------------------- |
| 符号位，与s相同 | exp filed encodes，不等于阶码 | frac field encodes，不等于M |

float类型和double类型的精度主要区别在Frac位的保存上。

#### 三种不同的编码形式

*(在计算机内同时使用，应用于不同大小范围的数字)* 

##### Normalized 规格化数

最常用的类型，用于储存大部分数字，不能储存非常小和无穷的数字

**特点**：Exp位不等于0或255。

Exp位是偏置(Biased)储存的，偏置$bias=2^{k-1}$(K是exp位的位数(8或11))。储存方式是$E=Exp+Bias$ 

Significant位在编码时默认忽略了开头的1(1.xxxxx)。

##### Denormalized 非规格化数

用来储存非常小，接近0的数字

**特点**：Exp位全部为0。

由于Exp位的结果位0，如果依照上面的偏置规则来看，E位应该为0-Bias。但是并不是，我们对结果做+1处理。所以实际上$E=1-Bias$。

而Significant位则默认省略了0(0.xxxxx)

##### Special Values 特殊情况

Exp位全为1，而frac位全为0时代表一个非常大的数（*超过储存范围，∞*）

而同时，frac不全为0代表出错了，结果不是数字

PS：非规格化数不以规格化数储存的原因之一是因为数字太小，继续去增大M，储存E的位数就不够用了。
















