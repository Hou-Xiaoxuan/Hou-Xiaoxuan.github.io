---
layout:     post
title:      数据结构与算法 期末复习笔记 #标题
subtitle:   时间不多了啊 #副标题
date:       2021-01-29 #日期
author:     Lin_Xuan
header-img: img/post-Note-Head-003-JW画师.jpg #图片
catalog: true
tags:
   - 复习
   - 笔记
---

# 数据结构期末复习

&emsp;&emsp;以理论知识为主，插入少量核心代码/伪代码。重点复习ACM中不用/少用的部分，略过ACM中的常用算法，因此个人特点明显，不适合用来系统的复习/学习。

------

## 参考知识点列表

<center><img src="https://s3.ax1x.com/2021/01/29/yFisrF.png" alt="参考知识点" style="zoom: 50%;" /></center>

## 复习中的不熟练、难点部分



# 线性表

&emsp;&emsp;线性表的含义是指数据的**逻辑关系**是顺序的。但是根据数据在**物理上的存储格式**的不同，区分为顺序表和链表两种(链表有分为单链表、双链表、循环链表)。

&emsp;&emsp;**链表的表头**：链表根据是否带有表头可以分为两种。表头即作为链表头部的一个指针节点，但是并不储存数据，只是方便一些操作。

&emsp;&emsp;**特殊的线性表**：加入一些限制/功能，如队列、栈……

## 错题汇总

- 链式储存所有的储存单元可连续可不连续(×)：<font color='red'>节点内的储存单元必须连续</font> 

- <font color='red'>在表元素序号的时候，一般从1开始。如插入第i个地方。</font> 

- 给定n个元素的以为数组，建立一个有序单链表的时间复杂度是\_\_\_\_? <font color='red'>$O(n^2)$,不可特殊化处理，链表的单次插入时$O(n)$。</font> 

- 双向链表储存结构优点是？<font color='red'>提高按关系查找元素的速度</font> 

  ------

- 有n个元素，次序进栈，出栈序列有\_\_种？<font color='red'>$\frac{C_{2n}^{n}}{n+1}$种</font> 

- <font color='red'>可以用两个栈模拟一个队列，但是不可以用两个队列模拟一个栈。</font> 

# 树结构

## 树

&emsp;&emsp;十分熟悉的数结构……在树结构中，**节点的度**的定义与图不同，此处定义外子节点的个数(**树的度**指树种节点的最大度数)。**节点的深度**定义为树种节点的最大层次，**层次**从0开始计，每向下层次+1(根为0)。**树的高**为最大层次再加一。

**基本性质**：

- 度为m的树，第`i`层最多有$m^i$个节点。

- 高度为h，度为m的树，最多有$\frac{m^{h-1}}{m+1}$个节点。

- 有n个节点，度为m的树，最小高度为$\lceil log_m(n(m-1))+1\rceil$。

## 二叉树

&emsp;&emsp;**完全二叉树**是节点编号与同深度的**满二叉树**相同的二叉树。即满二叉树的条件更为苛刻。

&emsp;&emsp;对于度数为0或1的节点，通过增加空树叶的形式使得所有的节点度数为2(除了空树叶，度数为0)，叫做**二叉树的扩充**。**外部路径和E**指的是根节点到*扩充后*的二叉树的所有节点的路径长度的和。内部路径和E指根节点到*扩充前*的所有节点的路径和。有关系$E=i+2n$，n为二叉树不含空树叶的节点数量。

**主要性质**：

&emsp;&emsp;设终端节点/空节点的数量为$n_0$，度为1，2的节点的数量分别是$n_1,n_2$,节点总数为$n$。

- $n_0=n_2+1$ 
- 树的深度为$\lceil log_2(n+1)\rceil$。

&emsp;&emsp;二叉树的遍历形式有三种：前序、中序、后续，指的是根节点再遍历时的次序。又有递归和非递归两种实现方式。其中，后续的非递归形式最复杂，必须增加指针或其他信息来判断节点是否已经被访问过。

## 二叉搜索树(AVL树)

&emsp;&emsp;满足节点的左孩子比节点小，右孩子比节点大的二叉树。可以实现二分的插入与搜索。但是，单纯的不断插入会使得树的的深度增加的过于快，极端情况变成单支，影响算法的复杂度，因此可以通过各种方式来平衡化处理。常见的平衡树有AVL树。

&emsp;&emsp;AVL树增加平衡因子$bf(x)$，定义为左子树与右子树的高度差。平衡的二叉树平衡因子的取址应该是-1，0，1。

### 主要操作

&emsp;&emsp;AVL树主要通过“旋转操作”来维持平衡因子再取值范围内。有四种不平衡状态，对应有两种单旋转和两种双旋转两种情况。其中又有左右对称两种情况。

<center><img src="https://s3.ax1x.com/2021/01/29/yFiyb4.png" style="zoom:67%;" /><br>AVL树的四种不平衡情况
</center>

&emsp;&emsp;由于操作的对称性，只复习LL和LR两种不平衡的旋转方式。

#### 单旋转：

&emsp;&emsp;LL和RR的情况需要做对称的单旋转处理。在图中的LL类型不平衡中，在左子树的左边插入1使得节点8的平衡因子变为-1，节点8失衡，因此针对节点8做**右单旋**处理。具体操作为：

- 确定失衡节点k1和k1的左孩子k2
- k1的左孩子指针指向k2的右孩子
- k2的右孩子指针指向k1

&emsp;&emsp;这样操作，使得k2替代k1的位置，同时仍然满足二叉搜索树的性质(左孩子比节点小，有孩子比节点大。因为k1是大于k2的，因此k2称为根后k1只能称为k1的右孩子。而k2原本的右孩子则作为k1的左孩子(左孩子位置本来是k2,已经移走了))。

```c++
    void rote_with_left(AVLNode* &k1)
    {
        // 右旋(左支旋转)
        AVLNode* k2=k1->left_child;//这里不能用引用
        k1->left_child=k2->right_child;
        k2->right_child=k1;
        //不要忘记更新高度
        k1->height=max(k1->left_child->height,k1->right_child->height)+1;
        k2->height=max(k2->left_child->height,k2->right_child->height)+1;
        k1=k2;
    }
```

&emsp;&emsp;RR的操作与LL的操作对称，需要做**左单旋**。

#### 双旋转：

&emsp;&emsp;针对LR和RL两种失衡，需要做两次单旋转，即双旋转才能恢复平衡。图中的LR失衡中，由于左子树的右子树插入5，使得节点8失衡。由于失衡位置在子树的右边，没办法通过一次旋转达到平衡，需要旋转两次，做**左右双旋**具体操作为：

- k1仍为失衡节点，但是k2仍为k1的左节点。
- 先以k2为失衡节点，做一次**左单旋**,再以k1为失衡节点，做一次对称的**右单旋**。

&emsp;&emsp;k2先进行一次左单旋后，平衡因子由原来的-1变为1，情况退化为LL的情况。那再做一次右单旋就解决问题了。

```c++
    void double_with_left(AVLNode* &k1)
    {
        // 左右双旋
        rote_with_right(k1->left_child);
        rote_with_left(k1);
    }
```
&emsp;&emsp; RL的操作与LR操作完全镜像。
#### 插入：

&emsp;&emsp;插入时,采用递归的方法。在回退时判断节点是否失衡。一旦失衡，根据情况进行旋转纠正即可，代码相对比较容易。

#### 删除：



# 图论



# 排序



# 查找



