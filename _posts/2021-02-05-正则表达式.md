---
layout:     post
title:      正则表达式 #标题
subtitle:   ddl好像过去好几天你了…… #副标题
date:       2021-02-05 #日期
author:     Lin_Xuan
header-img: img/post-Note-Head-時計師家-夜-ArseniXC.jpg #图片
catalog: true
tags:
   - ACM
   - 笔记
   - 正则表达式
---

# 正则表达式

参考资料： [正则表达式必知必会(修订版)](https://book.douban.com/subject/26285406/)   [度盘提取码：ga2g](https://pan.baidu.com/s/1hGCmB6HNB4T6OhbtFzBRLw) 

## 正则表达式入门

正则表达式是用于字符串匹配和替换的语言，但是没有单独的编译器/解释器，集成在了很多语言的内部。虽然在不同的语言中使用会有一点差距，但是核心语法相同。

### 单字符

**确定字符**：正则表达式可以是区分大小写的纯文本。

**任意字符**：对于不确定或无意义的字符，可以使用占位符`.`来代替。`.`可以连续出现，每一个`.`都代表任意一个字符(包括`.`本身)。如果需要特指字符`.`，可以使用转义字符`\`，写成`\.`的形式。

### 一组字符

例如想要得到文本中形式为"dot*"或"bot\*"的四字符字符串(\*代指任意字符)，可以用特殊字符\[\]来代替，\[\]中填写所有的目标字符。在上例中，对应的正则表达式为`[db]ot.`。d和b的顺序无影响。

**字符区间**：有时候，我们希望\[\]去匹配一系列字符，如数字0-9,大写字母A-F。虽然可以将符合要求的所有字符填入\[\]内，但是还可以用另一种表达。即正则表达式的**连字符**`-`。连字符与ASCII码有关。`[a-F]`会匹配ASCII在a和F之间的所有字符。\[\]内可以填入不止一对区间，例如`a-fA-F`会匹配所有的字母。

**取非匹配**：\[\]还可以填写不希望匹配的字符。则其他字符都可以匹配。使用元字符`^`。`[^0-9]`将匹配所有的非数字。`^`的效果作用于\[\]内的所有字符区间而不仅是其后一个。

### 元字符

正则表达式里的特殊字符，如果仅作为普通字符使用的话需要进行转义。创建的元字符：

| Backspace | 换页符     | 换行符         | 回车符           | 制表符                        | 垂直制表符     |
| --------- | ---------- | -------------- | ---------------- | ----------------------------- | -------------- |
| [\b]      | \f         | \n             | \r               | \t                            | \v             |
| 数字字符  | 非数字字符 | 字母数字下划线 | 非字母数字下划线 | 任何空白字符(\f\n\r\t\v,无\b) | 任何非空白字符 |
| \d        | \D         | \w             | \W               | \s                            | \S             |

正则表达式支持直接使用ASCII码来匹配字符，使用十六进制/八进制，如\x0A(十六进制，对应10)、\011(八进制，对应9)

另外，还有POXSIX字符类，可以直接代指特定的字符集合。但是并不是所有的语言都支持。例如javaScript就不支持POXISIX字符类。

| 字符类    | 说明 |
| --------- | ---- |
| [:alnum:] | 字母或数字，[a-zA-Z0-9] |
| [:alpha:]  | 字母，[a-zA-Z] |
| [:blank:]  | 空格或制表符，[\t ] |
| [:cntrl:]  | 控制符，ASCII0-31和127 |
| [:digit:]  | 数字，[0-9] |
| [:graph:]  | 可打印字符，不包括空格 |
| [:lower:]  | 小写字母[a-z] |
| [:print:]  | 可打印字符，包括空格 |
| [:punct:] | 不属于alnum和cntrl的任意字符 |
| [:space:]         | 任何空白字符，包括空格[\f\n\r\t\v] |
| [:upper:]   | 大写字母[A-Z] |
| [:xdigit] | 十六进制数字，[a-fA-F0-9] |

具体使用时，需要套上[]。即使用`[[xdigit]]`去匹配。

### 重复匹配

在字符或字符集的后面添加`+`表示重复匹配一个或多个该字符/字符集。例如使用`[[:digit]]+@w+\.[a-fA-F]+`可以匹配\*\*@\*\*.\*\*格式的电子邮箱。`+`也是元字符之一。

在字符/字符集后面添加`*`表示字符/字符集出现0次或多次的情况。

在字符/字符集后面添加`？`表示字符/字符集出现0次或1次的情况。

在字符/字符集后面添加`{n}`(n为数字)表示字符/字符集必须连续出现n次的情况。n也可以写成用`,`分割的区间的形式。如`a{2,4}`将匹配2\~4个连续的字母a。`[[:digit:]]{3, }`将匹配最少连续出现3次或以上的数字。

**贪婪形和懒惰型**：`*` ,`+`,`{n, }`将匹配尽可能多的字符。但是如果在后面加上字符`?`可以将模式改为最小匹配。如写成`*?`,`+?`,`{n, }?`

### 位置匹配



**字符边界**: 当我们想匹配的字符位于特定位置时，我们使用边界来限定。如搜索cat时不想搜索到scatter，就可以使用`\b`来限定开头和结尾（匹配一个非字母数字下划线的位置）。`\bcat\b`将只匹配到cat。这里的`\b`只**匹配位置，不匹配字符**。(也可以使用`\B`来限定没有边界)

**字符串边界**: 当我们想匹配字符串的特定位置时，有两个元字符可供选择。`^`,`$`。`^`有取非的意思，但是只有出现在字符集的开头部分时才表这一含义。当它出现在正则表达式的开头时，表示的是匹配字符串的开头。而`$`会匹配字符串的末尾。(正则表达式对**字符串的定义是传进来的所有字符**，都当作一个字符串)。

**分行匹配**: 正则表达式可以**使用一个元字符来改变另一个元字符的含义**。在正则表达式的开头使用`(?m)`将开启分**行匹配模式**。在这一模式下，正则表达式将**使用换行符来作为字符串的划分**。不再将所有的字符作为一个字符串。这时`^` 和`$`将匹配更多的位置。(*有些正则表达式不支持分行匹配*)

### 子表达式

`()`括起来的部分将作为一个整体，再匹配时被看作“一个字符”。这样，原本只能作用以一个字符/字符集的`?`, `*`, `+`, `{a,b}`等将可以作用与字符串片段。

为了增加代码的可读性，可以使用子表达式来对正则表达式做一定的划分。虽然一般情况下无影响，在有些实现方式里会影响执行效率。

**或 元字符**：在我们想要匹配年份的时候，我们寻找前两位时19或20的四位数字。可以使用`|`表示“或”的意思。但是`|`将左右两边的整体作为两个部分。因此可以使用`()`来限定`|`的使用范围。`(19|20)\d{2}`可以达成目的。

子表达式支持嵌套。

### 回溯引用

子表达式的另一个重要的应用。

**匹配**：

在想要使用正则表达式中取寻找两个连续的相同单词时，后面的表达式需要知道前面匹配到了什么。再这种情况下，就需要使用回溯引用。例如`[ ]+(\w+)[ ]+\1`。前面和后面的`[ ]+`匹配若干个空格，中间匹配任意一个单词。关键在于后面的`\1`。它就是**回溯引用**，代指正则表则式中出现的第一个子表达式。数字可以为1，2，3(第一个、第二个、第三个……一次类推)。再有些实现里，`\0`可以代指整个正则表达式。

**替换**：

在之前的应用中，正则表达式都是用来搜索。正则表达式的另一个重要作用是替换。而在替换操作中，最基本的就是用使用回溯引用。

例如，在文本中匹配到一个邮箱，改成`<A HREF="mailto:user@address.com">user@address.com</A>`(HTML)的格式。具体实现代码：

```python
(\w+{\w\.}*@{\w\.}+\.\w+)//搜索模式表达式
<A HREF="mailto:$1">$1</A>//替换模式
```

正则表达式可以跨模式使用。用`()`将搜索模式的表达式写成子表达式，就可以在替换模式中使用了。`$1`和`\1`效果相同。在不同的语言里又不同的要求。

**大小写转换**：

部分正则表达式可以使用元字符来改变字符的大小写。

| 元字符 | 说明             |
| ------ | ---------------- |
| \E     | 结束\L或\U转换   |
| \l     | 下一个字符转小写 |
| \L     | \L到\E之间转小写 |
| \u     | 下一个转大写     |
| \U     | \U到\E之间转大写 |

### 前后查找

当我们需要去标记待匹配的文本的位置时，比如查找\<\>括住的文本，我本可以这样`</w+>`但是，这样会多匹配出我们不需要的`<>`。从然我们可以自己剔除不需要的部分，但是，使用**前后查找**的方法，我们可以直接返回我们需要的部分。

前后查找分为向前查找和向后查找。常见的语言都支持向前查找，而支持向后查找的就没有那么多了。

**向前查找 ** 

向前查找在语法上是一个以`?=`开头的子表达式。例如`.+(?=:)`可以在一堆网址中搜索出协议名，但是省略掉写一名后面的':'字符。向前查找的子表达式可以出现在总表达式的任意位置。

**向后查找** 

向后查找模式的标志是`?<=`。使用方法类似，使用`(?<=\$)[0-9.]+`可以匹配形如`$12.34`的价格，但是会抛去`$`字符。

向前查找和向后查找意味着被抛去的字符在我们需要文本的前方/后方。<font color='red'>计算机处理的前后与我们阅读的前后顺序**相反**</font>。因此向后查找，被抛去的部分反而在文本的前面。理解为**向……之后、向……之前查找，更容易理解**。

向前查找模式的长度是可变的，可以使用`. +`等字符。但是向后查找的长度必须固定，不能使用重复匹配的元字符。

**向前查找和向后查找可以同时使用**。

**正/负向前/后查找**：

向前查找和向后查找默认都是正查找(positive look-ahead and positive look-behand)。还可以使用负查找(negative look-ahead and negative look-behand)，标识分别是`?=~`和`?<=!`对正查找取非，意味着搜索不在标记位置出的文本，但是不太常用。

### 嵌入条件

正则表达式可以在表达式内部嵌入条件处理功能，限制匹配到文本的格式。

```c++
123-456-7890 //合法
(123)456-7890 //合法
(123)-456-7890 //合法
(123-456-7890 //不合法
1234567890 //不合法
123 456 7890 //不合法
```

比如在上述的6个电话号码中查找出符合特定格式的号码。

在之前已经接触过一些条件了。如：

- `？`：匹配一个字符/表达式，如果它存在的话
- `?=` 、`?<=`：匹配前面或后面的文本，如果它存在的话

因此，条件也用`?`字符来实现。正则表达式的条件有两种。一种是根据**回溯引用**，一种是根据**前后查找**。

**回溯引用条件**：

回溯引用的格式是`((backreference)true-regex)`。括号里的backreference是一个回溯引用，后面的true-regex是一个子表达式。只有当backreference存在时，后面的true-regex才会执行。

例如，我们要从html文本中查找出所有的`<img>`标签。但是如何这个标签是连接(被`<a></a>`包含)的话，就把整个连接匹配出来。

```latex
([Aa]\s+[^>]+>\s*)?<[Ii][Mm][Gg]\s+[^>]+>(?(1)\s*</[Aa]>)
```

> 这个模式不解释是不容易看明白的。其中，`(<[Aa]\s+[">]+>\s*)?`将匹配一个`<A>`或`<a>`标签（以及`<A>`或`<a>`标签的任意屈性）。这个标签可有可无（因为这个子表达式的最后有一个`？`）。接下来`<[Ii][Mm][Gg]\s+[">]+>`
> 匹配一个<!MG> (大小写均可）及其任意屈性。`(?(1)\s*</[Aa]>)`是一个回溯引用条件， ?(1)的含义是： 如果第1个回溯引用（具体到本例，就是 `<A>`标签）存在， 则使用`\s*</[Aa]>`继续进行匹配。

因此，可以写出解决上面电话号码匹配问题的代码。使用`(\()?\d{3}(?(1)\|-)\d{3}-\d{4}`可以解决我们的问题。中间的`(?(1)\)|-`在前面匹配到`(`的情况下去匹配`)`。否则，就去匹配`-`。

**前后查找条件**：

前后查找条件与回溯引用条件极为接近，只是把回溯引用的编号替换成一个完整的正则表达式就可以了。

举个例子，匹配下列电话号码

```c++
11111//合法
22222//合法
33333-//不合法
44444-4444//合法
```

```latex
\d{5}(?(?=-)\-d{4})
```

在`(?=-)`成功匹配到`-`的情况下，才会匹配后面的`-`和四位数字。

**PS**：不知道为什么，所有的条件匹配代码在网页端测试均没有成功，目前原因未明。

## Python 中的正则表达式

## c++中的正则表达式



